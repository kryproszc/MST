import shinyswatch
import pandas as pd
import numpy as np
from shiny import App, Inputs, Outputs, Session, render, ui,run_app,reactive
from shiny.types import FileInfo
from shiny import experimental as x
import matplotlib.pyplot as plt
from shiny.types import ImgData
import shiny
from metody_jednoroczne_copy import YearHorizont
yh = YearHorizont()
# Dane
data = {
    "AY": [1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990],
    1: [5012, 106, 3410, 5655, 1092, 1513, 557, 1351, 3133, 2063],
    2: [8269, 4285, 8992, 11555, 9565, 6445, 4020, 6947, 5395, None],
    3: [10907, 5396, 13873, 15766, 15836, 11702, 10946, 13112, None, None],
    4: [11805, 10666, 16141, 21266, 22169, 12935, 12314, None, None, None],
    5: [13539, 13782, 18735, 23425, 25955, 15852, None, None, None, None],
    6: [16181, 15599, 22214, 26083, 26180, None, None, None, None, None],
    7: [18009, 15496, 22863, 27067, None, None, None, None, None, None],
    8: [18608, 16169, 23466, None, None, None, None, None, None, None],
    9: [18662, 16704, None, None, None, None, None, None, None, None],
    10: [18834, None, None, None, None, None, None, None, None, None]
}

df = pd.DataFrame(data)

def calculate_ratios(df):
   # print(df.to_string())
    ind_all, m_i, m_first = yh.index_all(df.iloc[:,1:])
    macierz_wsp_l = yh.l_i_j(df.iloc[:,1:], ind_all)


    #macierz_wsp_l_out = macierz_wsp_l.iloc[:-1,:-1]

    return macierz_wsp_l

def calculate_ratios_p_lr(df,expo):
    macierz_wsp_l = yh.wspolczynniki_LR_i_j(df.iloc[:,1:], expo)
    return macierz_wsp_l

def calculate_ratios_i_lr(df,expo):
    macierz_wsp_l = yh.wspolczynniki_LR_i_j(df.iloc[:,1:], expo)
    return macierz_wsp_l

def calculate_ratios_pi(df_paid,df_inc):
    macierz_wsp_pi =np.where(df_inc!=0,df_paid/df_inc,np.nan)
    macierz_wsp_pi_pd = pd.DataFrame(macierz_wsp_pi,columns=df_paid.columns)
    return macierz_wsp_pi_pd


def create_binary_df(ratio_df):
    binary_df = ratio_df.map(lambda x: 1 if pd.notna(x) else np.nan)
    return binary_df

#ratio_df = calculate_ratios(df)
#binary_df = create_binary_df(ratio_df)

js_code ="""
$(document).on('click', '#ratios-table-1 td', function() {
    var row = $(this).closest('tr').index();
    var col = $(this).index();
    if (col >= 0) {  // Uwzględnij pierwszą kolumnę
        console.log(`Cell clicked: row=${row}, col=${col}`);
        if ($(this).hasClass('highlighted')) {
            $(this).removeClass('highlighted');
            Shiny.setInputValue('clicked_cell_ratios_table_1', 
                { row: row, col: col, highlighted: false });
        } else {
            $(this).addClass('highlighted');
            Shiny.setInputValue('clicked_cell_ratios_table_1', 
                { row: row, col: col, highlighted: true });
        }
    }
});

let highlightedCells = [];

function highlight_default_cell(offset) {
    var table = document.getElementById('ratios-table-1');
    if (table) {
        console.log(`Highlighting cells with offset: ${offset}`);

        // Usuwanie istniejących podświetleń przed dodaniem nowych
        remove_highlights([]);

        if (offset === 0) {
            console.log("Offset is zero, no cells will be highlighted.");
            return;
        }

        let newHighlightedCells = [];
        let baseOffset = -1;
        let foundBase = false;

        for (let colIndex = 0; colIndex < table.rows[0].cells.length; colIndex++) {
            for (let rowIndex = table.rows.length - 1; rowIndex > 0; rowIndex--) {
                let cell = table.rows[rowIndex].cells[colIndex];
                if (cell.innerText.trim() !== '0') {
                    if (!foundBase) {
                        baseOffset = rowIndex;
                        foundBase = true;
                    }

                    let targetRow = baseOffset - (colIndex - 1) - offset-1;
                    if (targetRow >= 1) {
                        for (let highlightRow = targetRow; highlightRow >= 1; highlightRow--) {
                            let targetCell = table.rows[highlightRow].cells[colIndex];

                            if (!targetCell.classList.contains('highlighted')) {
                                targetCell.classList.add('highlighted');
                                newHighlightedCells.push({ row: highlightRow-1, col: colIndex, highlighted: true });
                            }
                        }
                    }
                    break;
                }
            }
        }

        highlightedCells = newHighlightedCells;

        // Wysyłanie wszystkich podświetlonych komórek jednocześnie do Shiny
        Shiny.setInputValue('all_generated_cells_ratios_table_1', highlightedCells, { priority: "event" });
    }
}

function remove_highlights(newHighlightedCells) {
    var table = document.getElementById('ratios-table-1');
    highlightedCells.forEach(function (cell) {
        var targetCell = table.rows[cell.row].cells[cell.col];
        if (!newHighlightedCells.some(newCell => newCell.row === cell.row && newCell.col === cell.col)) {
            targetCell.classList.remove('highlighted');
        }
    });
}

document.addEventListener('DOMContentLoaded', function () {
    Shiny.addCustomMessageHandler('highlight_cells', function (offset) {
        highlight_default_cell(offset);
    });
});

"""

js_code_pi_i = """
$(document).on('click', '#ratios-table-2 td', function() {
    var row = $(this).closest('tr').index();
    var col = $(this).index();
    if (col >= 0) {  // Uwzględnij pierwszą kolumnę
        console.log(`Cell clicked: row=${row}, col=${col}`);
        if ($(this).hasClass('highlighted')) {
            $(this).removeClass('highlighted');
            Shiny.setInputValue('clicked_cell_ratios_table_2', 
                { row: row, col: col, highlighted: false });
        } else {
            $(this).addClass('highlighted');
            Shiny.setInputValue('clicked_cell_ratios_table_2', 
                { row: row, col: col, highlighted: true });
        }
    }
});

let highlightedCellsIncurred = [];

function highlight_default_cell_incurred(offset) {
    var table = document.getElementById('ratios-table-2');
    if (table) {
        console.log(`Highlighting cells with offset: ${offset}`);

        // Usuwanie istniejących podświetleń przed dodaniem nowych
        remove_highlights_incurred([]);

        if (offset === 0) {
            console.log("Offset is zero, no cells will be highlighted.");
            return;
        }

        let newHighlightedCellsIncurred = [];
        let baseOffset = -1;
        let foundBase = false;

        for (let colIndex = 0; colIndex < table.rows[0].cells.length; colIndex++) {
            for (let rowIndex = table.rows.length - 1; rowIndex > 0; rowIndex--) {
                let cell = table.rows[rowIndex].cells[colIndex];
                if (cell.innerText.trim() !== '0') {
                    if (!foundBase) {
                        baseOffset = rowIndex;
                        foundBase = true;
                    }

                    let targetRow = baseOffset - (colIndex - 1) - offset-1;
                    if (targetRow >= 1) {
                        for (let highlightRow = targetRow; highlightRow >= 1; highlightRow--) {
                            let targetCell = table.rows[highlightRow].cells[colIndex];

                            if (!targetCell.classList.contains('highlighted')) {
                                targetCell.classList.add('highlighted');
                                newHighlightedCellsIncurred .push({ row: highlightRow-1, col: colIndex, highlighted: true });
                            }
                        }
                    }
                    break;
                }
            }
        }

        highlightedCellsIncurred = newHighlightedCellsIncurred ;

        // Wysyłanie wszystkich podświetlonych komórek jednocześnie do Shiny
        Shiny.setInputValue('all_generated_cells_ratios_table_2', highlightedCellsIncurred, { priority: "event" });
    }
}

function remove_highlights_incurred(newHighlightedCellsIncurred) {
    var table = document.getElementById('ratios-table-2');
    highlightedCellsIncurred.forEach(function (cell) {
        var targetCell = table.rows[cell.row].cells[cell.col];
        if (!newHighlightedCellsIncurred.some(newCell => newCell.row === cell.row && newCell.col === cell.col)) {
            targetCell.classList.remove('highlighted');
        }
    });
}

document.addEventListener('DOMContentLoaded', function () {
    Shiny.addCustomMessageHandler('highlight_cells', function (offset) {
        highlight_default_cell_incurred(offset);
    });
});

"""

js_code_p_lr ="""
 $(document).on('click', '#ratios-table-4 td', function() {
    var row = $(this).closest('tr').index();
    var col = $(this).index();
    if (col >= 0) {  // Uwzględnij pierwszą kolumnę
        console.log(`Cell clicked: row=${row}, col=${col}`);
        if ($(this).hasClass('highlighted')) {
            $(this).removeClass('highlighted');
            Shiny.setInputValue('clicked_cell_ratios_table_4', 
                { row: row, col: col, highlighted: false });
        } else {
            $(this).addClass('highlighted');
            Shiny.setInputValue('clicked_cell_ratios_table_4', 
                { row: row, col: col, highlighted: true });
        }
    }
});

let highlightedCells_p_lr = [];

function highlight_default_cell_p_lr(offset) {
    var table = document.getElementById('ratios-table-4');
    if (table) {
        console.log(`Highlighting cells with offset: ${offset}`);

        // Usuwanie istniejących podświetleń przed dodaniem nowych
        remove_highlights_p_lr([]);

        if (offset === 0) {
            console.log("Offset is zero, no cells will be highlighted.");
            return;
        }

        let newhighlightedCells_p_lr = [];
        let baseOffset = -1;
        let foundBase = false;

        for (let colIndex = 1; colIndex < table.rows[0].cells.length; colIndex++) {
            let foundBase = false;
            let baseOffset = -1;
            for (let rowIndex = table.rows.length-1; rowIndex > 0; rowIndex--) {
                let cell = table.rows[rowIndex].cells[colIndex];
                if (cell.innerText.trim() !== '0') {
                    if (!foundBase) {
                        baseOffset = rowIndex;
                        foundBase = true;
                    }

                    let targetRow = baseOffset - (colIndex ) - offset+1;
                    if (targetRow > 0) {
                        for (let highlightRow = targetRow; highlightRow >= 1; highlightRow--) {
                            let targetCell = table.rows[highlightRow].cells[colIndex];

                            if (!targetCell.classList.contains('highlighted')) {
                                targetCell.classList.add('highlighted');
                                newhighlightedCells_p_lr .push({ row: highlightRow-1, col: colIndex-1, highlighted: true });
                            }
                        }
                    }
                    break;
                }
            }
        }

        highlightedCells_p_lr = newhighlightedCells_p_lr ;

        // Wysyłanie wszystkich podświetlonych komórek jednocześnie do Shiny
        Shiny.setInputValue('all_generated_cells_ratios_table_4', highlightedCells_p_lr, { priority: "event" });
    }
}

function remove_highlights_p_lr(newhighlightedCells_p_lr) {
    var table = document.getElementById('ratios-table-4');
    highlightedCells_p_lr.forEach(function (cell) {
        var targetCell = table.rows[cell.row].cells[cell.col];
        if (!newhighlightedCells_p_lr.some(newCell => newCell.row === cell.row && newCell.col === cell.col)) {
            targetCell.classList.remove('highlighted');
        }
    });
}

document.addEventListener('DOMContentLoaded', function () {
    Shiny.addCustomMessageHandler('highlight_cells_p_lr', function (offset) {
        highlight_default_cell_p_lr(offset);
    });
});

"""



js_code_i_lr ="""
 $(document).on('click', '#ratios-table-5 td', function() {
    var row = $(this).closest('tr').index();
    var col = $(this).index();
    if (col >= 0) {  // Uwzględnij pierwszą kolumnę
        console.log(`Cell clicked: row=${row}, col=${col}`);
        if ($(this).hasClass('highlighted')) {
            $(this).removeClass('highlighted');
            Shiny.setInputValue('clicked_cell_ratios_table_5', 
                { row: row, col: col, highlighted: false });
        } else {
            $(this).addClass('highlighted');
            Shiny.setInputValue('clicked_cell_ratios_table_5', 
                { row: row, col: col, highlighted: true });
        }
    }
});

let highlightedCells_i_lr = [];

function highlight_default_cell_i_lr(offset) {
    var table = document.getElementById('ratios-table-5');
    if (table) {
        console.log(`Highlighting cells with offset: ${offset}`);

        // Usuwanie istniejących podświetleń przed dodaniem nowych
        remove_highlights_i_lr([]);

        if (offset === 0) {
            console.log("Offset is zero, no cells will be highlighted.");
            return;
        }

        let newhighlightedCells_i_lr = [];
        let baseOffset = -1;
        let foundBase = false;

        for (let colIndex = 1; colIndex < table.rows[0].cells.length; colIndex++) {
            let foundBase = false;
            let baseOffset = -1;
            for (let rowIndex = table.rows.length-1; rowIndex > 0; rowIndex--) {
                let cell = table.rows[rowIndex].cells[colIndex];
                if (cell.innerText.trim() !== '0') {
                    if (!foundBase) {
                        baseOffset = rowIndex;
                        foundBase = true;
                    }

                    let targetRow = baseOffset - (colIndex ) - offset+1;
                    if (targetRow > 0) {
                        for (let highlightRow = targetRow; highlightRow >= 1; highlightRow--) {
                            let targetCell = table.rows[highlightRow].cells[colIndex];

                            if (!targetCell.classList.contains('highlighted')) {
                                targetCell.classList.add('highlighted');
                                newhighlightedCells_i_lr .push({ row: highlightRow-1, col: colIndex-1, highlighted: true });
                            }
                        }
                    }
                    break;
                }
            }
        }

        highlightedCells_i_lr = newhighlightedCells_i_lr ;

        // Wysyłanie wszystkich podświetlonych komórek jednocześnie do Shiny
        Shiny.setInputValue('all_generated_cells_ratios_table_5', highlightedCells_i_lr, { priority: "event" });
    }
}

function remove_highlights_i_lr(newhighlightedCells_i_lr) {
    var table = document.getElementById('ratios-table-5');
    highlightedCells_i_lr.forEach(function (cell) {
        var targetCell = table.rows[cell.row].cells[cell.col];
        if (!newhighlightedCells_i_lr.some(newCell => newCell.row === cell.row && newCell.col === cell.col)) {
            targetCell.classList.remove('highlighted');
        }
    });
}

document.addEventListener('DOMContentLoaded', function () {
    Shiny.addCustomMessageHandler('highlight_cells_i_lr', function (offset) {
        highlight_default_cell_i_lr(offset);
    });
});

"""


js_code_pi_lr =  """
$(document).on('click', '#ratios-table-6 td', function() {
    var row = $(this).closest('tr').index();
    var col = $(this).index();
    if ($(this).hasClass('highlighted')) {
        $(this).removeClass('highlighted');
        Shiny.setInputValue('clicked_cell_ratios_table_6', {row: row, col: col - 1, highlighted: false});
    } else {
        $(this).addClass('highlighted');
        Shiny.setInputValue('clicked_cell_ratios_table_6', {row: row, col: col - 1, highlighted: true});
    }
});
"""

css_code = """
.highlighted {
    background-color: gray !important;
}
"""


import os


# Funkcja do wczytywania danych z Excela
def load_excel_data(folder_path, file_name, sheet_name, start_row, start_col, end_row, end_col):
    # Zmiana ukośników z \ na / w ścieżce do folderu
    folder_path = folder_path.replace("\\", "/")

    # Tworzymy pełną ścieżkę do pliku Excel
    file_path = os.path.join(folder_path, file_name)

    # Używamy pandas do wczytania danych z określonego arkusza i zakresu
    data = pd.read_excel(file_path,
                         sheet_name=sheet_name,
                         header=None,  # Oznacza, że nie traktujemy żadnego wiersza jako nagłówka
                         engine="openpyxl",
                         skiprows=start_row - 1,  # Pomijamy wiersze przed startowym wierszem
                         usecols=range(start_col - 1, end_col),  # Wczytujemy tylko wybrany zakres kolumn
                         nrows=end_row - start_row + 1)
    #data.insert(0, "Czas szkody", data.index.tolist())
    #data.insert(0, "Czas szkody", data.index.tolist())
    return data


##############


app_ui = ui.page_fluid(ui.page_navbar(
    shinyswatch.theme.superhero(),
    ui.nav_panel("REZERWY TESTY", ui.output_image("image")),
    ui.nav_panel("Wprowadź dane",
        ui.row(
            ui.column(
                4,
                "Wprowadź trójkąt Paid",
                ui.input_text("folder_path", "Ścieżka do folderu:", value="C:/Users/Documents"),
                ui.input_text("file_name", "Nazwa pliku Excel:", value="plik.xlsx"),
                ui.input_text("sheet_name", "Nazwa arkusza:", value="Arkusz1"),
                ui.input_numeric("start_row", "Wiersz początkowy:", value=2),
                ui.input_numeric("start_col", "Kolumna początkowa:", value=2),
                ui.input_numeric("end_row", "Wiersz końcowy:", value=5),
                ui.input_numeric("end_col", "Kolumna końcowa:", value=4),
                ui.input_radio_buttons(
                    "radio_button_paid",
                    "Wartości trójkata",
                    {
                        "Skumulowane": "Skumulowane",
                        "Inkrementalne": "Inkrementalne"
                    }, ),
                ui.input_action_button("load_button", "Wczytaj dane"),

            ),
            ui.column(
                4,
                "Wprowadź trójkąt Incurred",
                ui.input_text("folder_path_inc", "Ścieżka do folderu:", value="C:/Users/Documents"),
                ui.input_text("file_name_inc", "Nazwa pliku Excel:", value="plik.xlsx"),
                ui.input_text("sheet_name_inc", "Nazwa arkusza:", value="Arkusz1"),
                ui.input_numeric("start_row_inc", "Wiersz początkowy:", value=2),
                ui.input_numeric("start_col_inc", "Kolumna początkowa:", value=2),
                ui.input_numeric("end_row_inc", "Wiersz końcowy:", value=5),
                ui.input_numeric("end_col_inc", "Kolumna końcowa:", value=4),
                ui.input_radio_buttons(
                    "radio_button_inc",
                    "Wartości trójkata",
                    {
                        "Skumulowane":"Skumulowane",
                        "Inkrementalne":"Inkrementalne"
                    },),
                ui.input_action_button("load_button_inc", "Wczytaj dane")
            ),
            ui.column(
                4,
                "Wprowadź trójkąt ekspozycję",
                ui.input_text("folder_path_eksp", "Ścieżka do folderu:", value="C:/Users/Documents"),
                ui.input_text("file_name_eksp", "Nazwa pliku Excel:", value="plik.xlsx"),
                ui.input_text("sheet_name_eksp", "Nazwa arkusza:", value="Arkusz1"),
                ui.input_numeric("start_row_eksp", "Wiersz początkowy:", value=2),
                ui.input_numeric("start_col_eksp", "Kolumna początkowa:", value=2),
                ui.input_numeric("end_row_eksp", "Wiersz końcowy:", value=5),
                ui.input_numeric("end_col_eksp", "Kolumna końcowa:", value=4),
                ui.input_action_button("load_button_eksp", "Wczytaj dane")
            ),
        ),

           ),
    ui.nav_panel("Metody deterministyczne",ui.navset_tab(
        ui.nav_panel('Chain-Ladder Paid', ui.layout_sidebar(ui.panel_sidebar(ui.input_selectize("linie_biznesowe_CL_Paid", "Wybierz linię biznesową", choices=['MTPL_I'], multiple=False),
                                                                       ui.input_numeric("offset_distance",
                                                                                        "Pozostawiona liczba przekątnych", value=0,
                                                                                        min=0),

                                                                       ui.input_checkbox("dop_all_factor",
                                                                               "Dopasuj do wszystkich współczynników",
                                                                               True),
                                                             ui.input_selectize('chose_CL',
                                                                                'Wybierz CL do dopasowania krzywej',
                                                                                choices=[int(x) for x in range(1, 1000)], multiple=True),
                                                             ui.input_action_button("accept_CL", "Dopasuj krzywą",
                                                                                    class_="btn-success"),
                                                             ui.input_numeric("num_of_first_factor",
                                                                              "Pozostaw rzeczywistych współczynników",
                                                                              value=1),
                                                             ui.input_numeric("num_tail",
                                                                              "Ilość obserwacji w ogonie",
                                                                              value=0),
                                                             ui.input_action_button("accept_final_factor", "Zatwierdź",
                                                                                    class_="btn-success"),
                                                             ui.input_selectize("wyb_krzywa_ogona",
                                                                                "Wybierz ogon z krzywej",
                                                                                choices=['Exponential', 'Power',
                                                                                         "Weibull", "Inverse Power"],
                                                                                multiple=False),
                                                            ui.input_text("folder_path_save_p_cl",
                                                                                           "Ścieżka do folderu:",
                                                                                           value="C:/Users/Documents"),
                                                            ui.input_text("file_name_save_p_cl",
                                                                                           "Nazwa pliku Excel:",
                                                                                           value="plik.xlsx"),
                                                            ui.input_action_button("save_button_save_p_cl",
                                                                                                    "Zapisz tabelę"),

                                          width = 2,),
            ui.panel_main(
                ui.navset_tab(
                    ui.nav_panel("Trójkąt",
                        ui.output_ui("triangle_table"),
                    ),
                    ui.nav_panel("Współczynniki CL",
                           ui.output_ui("ratios_table_ui_p")
                           ),
                    ui.nav_panel("Wagi",
                           ui.output_ui("binary_ratios_table_ui_p")
                           ),
                    ui.nav_panel("Dopasowanie krzywej CL",
                            ui.page_fillable(shiny.ui.page_fillable(x.ui.card(ui.output_data_frame("macierz_wspol_CL_interaktywna"), ),
                                                                       height=180)),
                                    ui.page_fillable(shiny.ui.page_fillable( x.ui.card(
                                        ui.output_data_frame("wspol_z_krzywej_CL_paid_interaktywna"), ), height=230)),
                                       shiny.ui.page_fillable(

                                           x.ui.card(
                                               ui.output_plot("plot_wspolczynniki_dopasowane_interaktywny"),
                                           ),
                                           height=400),
                                   ui.page_fillable(shiny.ui.page_fillable( x.ui.card(
                                       ui.output_data_frame("r2_cl_paid"), ),
                                                                              height=100)),
                           ),
                    ui.nav_panel("Wybór krzywej CL",
                           shiny.ui.page_fillable( x.ui.card(
                               ui.output_data_frame(
                                   "Factors_curve_and_initial"), ),
                                                   height=300),
                           ui.page_fillable(
                               shiny.ui.page_fillable( x.ui.card(
                                   ui.output_data_frame(
                                       "Final_Factor"), ), height=300)),

                           ui.page_fillable(
                               shiny.ui.page_fillable( x.ui.card(
                                   ui.output_data_frame(
                                       "Choose_Factor"), ), height=300)),

                           ),
                    ui.nav_panel("Wyniki",
                        ui.page_fillable(shiny.ui.page_fillable( x.ui.card(
                            ui.output_data_frame("Ult_BE_data_interaktywne"), ), height=750)),
                           ),
                ),
                ui.tags.style(css_code),
                ui.tags.script(js_code)
            )
                                            )),
        ui.nav_panel('Chain-Ladder Incurred', ui.layout_sidebar(ui.panel_sidebar(
            ui.input_selectize("linie_biznesowe_CL_Incurred", "Wybierz linię biznesową", choices=['MTPL_I'],
                               multiple=False),
            ui.input_numeric("offset_distance_incurred", "Pozostawiona liczba przekątnych", value=0, min=0),
            ui.input_checkbox("dop_all_factor_i_cl",
                              "Dopasuj do wszystkich współczynników",
                              True),
            ui.input_selectize('chose_CL_i_cl',
                               'Wybierz CL do dopasowania krzywej',
                               choices=[int(x) for x in range(1, 1000)], multiple=True),
            ui.input_action_button("accept_CL_i_cl", "Dopasuj krzywą",
                                   class_="btn-success"),
            ui.input_numeric("num_of_first_factor_i_cl",
                             "Pozostaw rzeczywistych współczynników",
                             value=1),
            ui.input_numeric("num_tail_i_cl",
                             "Ilość obserwacji w ogonie",
                             value=0),
            ui.input_action_button("accept_final_factor_i_cl", "Zatwierdź",
                                   class_="btn-success"),
            ui.input_selectize("wyb_krzywa_ogona_i_cl",
                               "Wybierz ogon z krzywej",
                               choices=['Exponential', 'Power',
                                        "Weibull", "Inverse Power"],
                               multiple=False),
            ui.input_text("folder_path_save_i_cl",
                          "Ścieżka do folderu:",
                          value="C:/Users/Documents"),
            ui.input_text("file_name_save_i_cl",
                          "Nazwa pliku Excel:",
                          value="plik.xlsx"),
            ui.input_action_button("save_button_save_i_cl",
                                   "Zapisz tabelę"),
            width=2, ),
            ui.navset_tab(
                ui.nav_panel("Trójkąt Inc",
                       ui.output_ui("triangle_table_pi_i"),
                       ),
                ui.nav_panel("Współczynniki CL",
                       ui.output_ui("ratios_table_ui_pi_i")
                       ),
                ui.nav_panel("Wagi",
                       ui.output_ui("binary_ratios_table_ui_pi_i")
                       ),
                ui.nav_panel("Dopasowanie krzywej CL",
                       ui.page_fillable(shiny.ui.page_fillable( x.ui.card(
                           ui.output_data_frame("macierz_wspol_CL_interaktywna_i_cl"), ),
                                                                  height=180)),
                       ui.page_fillable(shiny.ui.page_fillable( x.ui.card(
                           ui.output_data_frame("wspol_z_krzywej_CL_paid_interaktywna_i_cl"), ), height=230)),
                       shiny.ui.page_fillable(

                           x.ui.card(
                               ui.output_plot("plot_wspolczynniki_dopasowane_interaktywny_i_cl"),
                           ),
                           height=400),
                       ui.page_fillable(shiny.ui.page_fillable( x.ui.card(
                           ui.output_data_frame("r2_cl_paid_i_cl"), ),
                                                                  height=100)),
                       ),
                ui.nav_panel("Wybór krzywej CL",
                       shiny.ui.page_fillable( x.ui.card(
                           ui.output_data_frame(
                               "Factors_curve_and_initial_i_cl"), ),
                                               height=300),
                       ui.page_fillable(
                           shiny.ui.page_fillable( x.ui.card(
                               ui.output_data_frame(
                                   "Final_Factor_i_cl"), ), height=300)),

                       ui.page_fillable(
                           shiny.ui.page_fillable( x.ui.card(
                               ui.output_data_frame(
                                   "Choose_Factor_i_cl"), ), height=300)),

                       ),
                ui.nav_panel("Wyniki",
                       ui.page_fillable(shiny.ui.page_fillable( x.ui.card(
                           ui.output_data_frame("Ult_BE_data_interaktywne_i_cl"), ), height=750)),

                       ),

            ),
            ui.tags.style(css_code),
            ui.tags.script(js_code_pi_i),
            #ui.tags.script(js_code_pi_pi)


        )
               ),
        ui.nav_panel('Addytywna Paid', ui.layout_sidebar(ui.panel_sidebar(
            ui.input_selectize("linie_biznesowe_LR_Paid", "Wybierz linię biznesową", choices=['MTPL_I'],
                               multiple=False),
            ui.input_numeric("offset_distance_p_lr", "Pozostawiona liczba przekątnych", value=0, min=0),

            ui.input_checkbox("dop_all_factor_p_lr",
                              "Dopasuj do wszystkich współczynników",
                              True),
            ui.input_selectize('chose_CL_p_lr',
                               'Wybierz CL do dopasowania krzywej',
                               choices=[int(x) for x in range(1, 1000)], multiple=True),
            ui.input_action_button("accept_p_lr", "Dopasuj krzywą",
                                   class_="btn-success"),
            ui.input_numeric("num_of_first_factor_p_lr",
                             "Pozostaw rzeczywistych współczynników",
                             value=1),
            ui.input_numeric("num_tail_p_lr",
                             "Ilość obserwacji w ogonie",
                             value=0),
            ui.input_action_button("accept_final_factor_p_lr", "Zatwierdź",
                                   class_="btn-success"),
            ui.input_selectize("wyb_krzywa_ogona_p_lr",
                               "Wybierz ogon z krzywej",
                               choices=['Exponential', 'Power',
                                        "Weibull", "Inverse Power"],
                               multiple=False),
            ui.input_text("folder_path_save_p_lr",
                          "Ścieżka do folderu:",
                          value="C:/Users"),
            ui.input_text("file_name_save_p_lr",
                          "Nazwa pliku Excel:",
                          value="plik.xlsx"),
            ui.input_action_button("save_button_save_p_lr",
                                   "Zapisz tabelę"),
            width=2, ),
            ui.panel_main(
                ui.navset_tab(
                    ui.nav_panel("Trójkąt",
                        ui.output_ui("triangle_table_p_lr"),
                    ),
                    ui.nav_panel("Współczynniki LR",
                           ui.output_ui("ratios_table_ui_p_lr")
                           ),
                    ui.nav_panel("Wagi",
                           ui.output_ui("binary_ratios_table_ui_p_lr")
                           ),
                    ui.nav_panel("Dopasowanie krzywej CL",
                           ui.page_fillable(shiny.ui.page_fillable( x.ui.card(
                               ui.output_data_frame("macierz_wspol_CL_interaktywna_p_lr"), ),
                                                                      height=180)),
                           ui.page_fillable(shiny.ui.page_fillable( x.ui.card(
                               ui.output_data_frame("wspol_z_krzywej_CL_paid_interaktywna_p_lr"), ), height=230)),
                           shiny.ui.page_fillable(

                               x.ui.card(
                                   ui.output_plot("plot_wspolczynniki_dopasowane_interaktywny_p_lr"),
                               ),
                               height=400),
                           ui.page_fillable(shiny.ui.page_fillable(x.ui.card(
                               ui.output_data_frame("r2_cl_paid_p_lr"), ),
                                                                      height=100)),
                           ),
                    ui.nav_panel("Wybór krzywej CL",
                           shiny.ui.page_fillable(x.ui.card(
                               ui.output_data_frame(
                                   "Factors_curve_and_initial_p_lr"), ),
                                                   height=300),
                           ui.page_fillable(
                               shiny.ui.page_fillable( x.ui.card(
                                   ui.output_data_frame(
                                       "Final_Factor_p_lr_out"), ), height=300)),

                           ui.page_fillable(
                               shiny.ui.page_fillable( x.ui.card(
                                   ui.output_data_frame(
                                       "Choose_Factor_p_lr"), ), height=300)),

                           ),
                    ui.nav_panel("Wyniki",
                           ui.page_fillable(shiny.ui.page_fillable( x.ui.card(
                               ui.output_data_frame("Ult_BE_data_interaktywne_p_lr"), ), height=750)),

                           ),

                ),
                ui.tags.style(css_code),
                ui.tags.script(js_code_p_lr)
            )

        )
               ),
        ui.nav_panel('Addytywna Incurred', ui.layout_sidebar(ui.panel_sidebar(
            ui.input_selectize("linie_biznesowe_LR_Incurred", "Wybierz linię biznesową",
                               choices=['MTPL_I'],
                               multiple=False),
            ui.input_numeric("offset_distance_i_lr", "Pozostawiona liczba przekątnych", value=0, min=0),

            ui.input_checkbox("dop_all_factor_i_lr",
                              "Dopasuj do wszystkich współczynników",
                              True),
            ui.input_selectize('chose_CL_i_lr',
                               'Wybierz CL do dopasowania krzywej',
                               choices=[int(x) for x in range(1, 1000)], multiple=True),
            ui.input_action_button("accept_i_lr", "Dopasuj krzywą",
                                   class_="btn-success"),
            ui.input_numeric("num_of_first_factor_i_lr",
                             "Pozostaw rzeczywistych współczynników",
                             value=1),
            ui.input_numeric("num_tail_i_lr",
                             "Ilość obserwacji w ogonie",
                             value=0),
            ui.input_action_button("accept_final_factor_i_lr", "Zatwierdź",
                                   class_="btn-success"),
            ui.input_selectize("wyb_krzywa_ogona_i_lr",
                               "Wybierz ogon z krzywej",
                               choices=['Exponential', 'Power',
                                        "Weibull", "Inverse Power"],
                               multiple=False),
            ui.input_text("folder_path_save_i_lr",
                          "Ścieżka do folderu:",
                          value="C:/Users/Documents"),
            ui.input_text("file_name_save_i_lr",
                          "Nazwa pliku Excel:",
                          value="plik.xlsx"),
            ui.input_action_button("save_button_save_i_lr",
                                   "Zapisz tabelę"),
            width=2, ),
            ui.panel_main(
                ui.navset_tab(
                    ui.nav_panel("Trójkąt",
                        ui.output_ui("triangle_table_i_lr"),
                    ),
                    ui.nav_panel("Współczynniki LR",
                           ui.output_ui("ratios_table_ui_i_lr")
                           ),
                    ui.nav_panel("Wagi",
                           ui.output_ui("binary_ratios_table_ui_i_lr")
                           ),
                    ui.nav_panel("Dopasowanie krzywej CL",
                           ui.page_fillable(shiny.ui.page_fillable( x.ui.card(
                               ui.output_data_frame("macierz_wspol_CL_interaktywna_i_lr"), ),
                                                                      height=180)),
                           ui.page_fillable(shiny.ui.page_fillable( x.ui.card(
                               ui.output_data_frame("wspol_z_krzywej_CL_paid_interaktywna_i_lr"), ), height=230)),
                           shiny.ui.page_fillable(

                               x.ui.card(
                                   ui.output_plot("plot_wspolczynniki_dopasowane_interaktywny_i_lr"),
                               ),
                               height=400),
                           ui.page_fillable(shiny.ui.page_fillable( x.ui.card(
                               ui.output_data_frame("r2_cl_paid_i_lr"), ),
                                                                      height=100)),
                           ),
                    ui.nav_panel("Wybór krzywej CL",
                           shiny.ui.page_fillable( x.ui.card(
                               ui.output_data_frame(
                                   "Factors_curve_and_initial_i_lr"), ),
                                                   height=300),
                           ui.page_fillable(
                               shiny.ui.page_fillable( x.ui.card(
                                   ui.output_data_frame(
                                       "Final_Factor_i_lr_out"), ), height=300)),

                           ui.page_fillable(
                               shiny.ui.page_fillable( x.ui.card(
                                   ui.output_data_frame(
                                       "Choose_Factor_i_lr"), ), height=300)),

                           ),
                    ui.nav_panel("Wyniki",
                           ui.page_fillable(shiny.ui.page_fillable( x.ui.card(
                               ui.output_data_frame("Ult_BE_data_interaktywne_i_lr"), ), height=750)),

                           ),

                ),
                ui.tags.style(css_code),
                ui.tags.script(js_code_i_lr),
                ui.tags.script(js_code_pi_lr),

            )

        )
               ),)),
    title="",

),
ui.tags.style("""
    #triangle_table, #triangle_table th, #triangle_table td {
        white-space: nowrap;  /* Zapobiega zawijaniu tekstu w komórkach */
        text-align: right;  /* Wyśrodkowanie liczb */
    }
        #triangle_table_pi_i, #triangle_table_pi_i th, #triangle_table_pi_i td {
        white-space: nowrap;  /* Zapobiega zawijaniu tekstu w komórkach */
        text-align: right;  /* Wyśrodkowanie liczb */
    }
        #triangle_table_p_lr, #triangle_table_p_lr th, #triangle_table_p_lr td {
        white-space: nowrap;  /* Zapobiega zawijaniu tekstu w komórkach */
        text-align: right;  /* Wyśrodkowanie liczb */
    }
        #triangle_table_i_lr, #triangle_table_i_lr th, #triangle_table_i_lr td {
        white-space: nowrap;  /* Zapobiega zawijaniu tekstu w komórkach */
        text-align: right;  /* Wyśrodkowanie liczb */
    }
""")
)


def server(input: Inputs, output: Outputs, session: Session):
    clicked_cells_p = reactive.Value([])
    update_trigger_p = reactive.Value(0)
    update_trigger_pi_i = reactive.Value(0)
    update_trigger_pi_pi = reactive.Value(0)
    update_trigger_p_lr = reactive.Value(0)
    update_trigger_i_lr = reactive.Value(0)
    update_trigger_pi_lr = reactive.Value(0)
    reactive_data = reactive.Value(pd.DataFrame())
    reactive_data_inc = reactive.Value(pd.DataFrame())
    reactive_data_eksp = reactive.Value(pd.DataFrame())


    linia_biznesowa = reactive.Value(0)
    #print(reactive.Value(0))
    global ratio_df_p, binary_df_p
    global ratio_df_pi_i, binary_df_pi_i
    global ratio_df_pi_pi, binary_df_pi_pi
    global ratio_df_p_lr, binary_df_p_lr
    global ratio_df_i_lr, binary_df_i_lr
    global ratio_df_pi_lr, binary_df_pi_lr

    ########################################## paid CL
    @output
    @render.ui
    def triangle_table():
        trian_list = every_triangle()[0]
        trian_for_line = trian_list[index_lini_CL_Paid()]
        index_linii = index_lini_CL_Paid()
        update_global_variables(index_linii)
        df_copy = trian_for_line.copy()

        df_copy.iloc[:,1:] = df_copy.iloc[:,1:].map(lambda x: f"{x:,.2f}".replace(",", " ") if isinstance(x, (int, float)) else x)


        return ui.HTML(
            df_copy.to_html(classes='table table-striped table-hover'))

    def update_global_variables(ind_linii):
        global ratio_df_p, binary_df_p
        trian_list = every_triangle()[0]
        trian_for_line = trian_list[ind_linii]
        ratio_df_p = calculate_ratios(trian_for_line)
        binary_df_p = create_binary_df(ratio_df_p)

    clicked_cells_p = reactive.Value([])

   # def update_global_variables(ind_linii):
    #    global ratio_df_p, binary_df_p
    #    trian_list = every_triangle()[0]
     #   trian_for_line = trian_list[ind_linii]
     #   ratio_df_p = calculate_ratios(trian_for_line)
     #   binary_df_p = create_binary_df(ratio_df_p)

    clicked_cells_p = reactive.Value([])

    @reactive.Effect
    @reactive.event(lambda: input.clicked_cell_ratios_table_1())
    def update_clicked_cell_p():
        cell = input.clicked_cell_ratios_table_1()
        if cell:
            row, col, highlighted = cell['row'], cell['col']-1, cell['highlighted']
            if row < binary_df_p.shape[0] and col < binary_df_p.shape[1]:  # Check bounds
                if highlighted:
                    binary_df_p.iat[row, col] = 0
                else:
                    binary_df_p.iat[row, col] = 1
                update_trigger_p.set(update_trigger_p.get() + 1)

    @reactive.Effect
    @reactive.event(input.offset_distance)
    async def update_highlight_default_cell():
        offset = input.offset_distance()
        if offset == 0:
            await session.send_custom_message('highlight_cells', 0)
        else:
            await session.send_custom_message('highlight_cells', offset)

    @reactive.Effect
    @reactive.event(lambda: input.all_generated_cells_ratios_table_1())
    def update_all_generated_cells():
        cells = input.all_generated_cells_ratios_table_1()
        print(cells)
        if cells:
            for cell in cells:
                row, col, highlighted = cell['row']-1 , cell['col'], cell['highlighted']
                if row < binary_df_p.shape[0] and col < binary_df_p.shape[1]:  # Sprawdzenie zakresów
                    if highlighted:
                        binary_df_p.iat[row, col] = 0
                    else:
                        binary_df_p.iat[row, col] = 1
            update_trigger_p.set(update_trigger_p.get() + 1)

    @output
    @render.ui
    def ratios_table_ui_p():
        update_global_variables(linia_biznesowa.get())
        return ui.HTML(
            ratio_df_p.to_html(classes='table table-striped table-hover', table_id="ratios-table-1")
        ), ui.tags.script("highlight_default_cell(" + str(input.offset_distance()) + ");")

    @output
    @render.ui
    def binary_ratios_table_ui_p():
        update_trigger_p.get()
        df = binary_df_p.copy()
        return ui.HTML(
            df.to_html(classes='table table-striped table-hover', table_id="binary-ratios-table-1", na_rep='NaN',
                       float_format='{:.0f}'.format))

    # @reactive.Calc
    #@reactive.Calc
    @reactive.event(input.clicked_cell_ratios_table_1)
    def wspolczynniki_multiplikatywna_interaktywna():
        trian_list = every_triangle()[0]
        trian_for_line = trian_list[index_lini_CL_Paid()]
        triagnle = trian_for_line.iloc[:, 1:]
        binary_df_deterministic = create_binary_df(triagnle)
        ind_all, m_i, m_first = yh.index_all(triagnle)
        macierz_wsp_l = yh.l_i_j(triagnle, ind_all)
        Dev_j_deterministic = yh.Dev(triagnle, binary_df_deterministic, macierz_wsp_l, ind_all)
        Dev_j = yh.Dev(triagnle, binary_df_p, macierz_wsp_l, ind_all)
        sigma_j = yh.sigma(triagnle, binary_df_p, macierz_wsp_l, Dev_j, ind_all)
        sd_j = yh.wspolczynnik_sd(triagnle, binary_df_p, sigma_j, ind_all)
        sd_pd = [x ** 2 for x in sd_j]
        I_dataframe = pd.DataFrame(index=['CL_base', 'CL'],
                                   columns=["Wybór"] + ['dp: ' + str(j) for j in range(1, len(Dev_j) + 1)])
        I_dataframe.iloc[0, :] = ["CL_base"] + Dev_j_deterministic
        I_dataframe.iloc[1, :] = ["CL"] + Dev_j
        return (I_dataframe)

    @output
    @render.data_frame
    def macierz_wspol_CL_interaktywna():
        df_out_mult= wspolczynniki_multiplikatywna_interaktywna()
        return render.DataGrid(
            df_out_mult,
            width="100%",
            height="150%",
        )

    @reactive.Calc
    @reactive.event(input.accept_CL, ignore_none=False)
    def wsp_mult_paid():
        ys = []
        xs = []
        y = wspolczynniki_multiplikatywna_interaktywna().iloc[1, 1:].tolist()
        if (input.dop_all_factor() == True):
            ii = 0
            for k in range(1, len(y) + 1):
                ii = ii + 1
                if (y[k - 1] > 1):
                    ys.append(y[k - 1])
                    xs.append(ii)
        elif (input.dop_all_factor() == False):
            for chose_factor in input.chose_CL():
                ys.append(y[int(chose_factor) - 1])
                xs.append(int(chose_factor))
        print(xs)
        return ([np.array(xs, dtype=np.float64), np.array(ys, dtype=np.float64)])

    #   @reactive.Effect
    #  def _():
    #      ui.update_selectize('chose_CL', choices=[str(x) for x in range(1, wspolczynniki_multiplikatywna_interaktywna.shape[1])])

    @reactive.Calc
    @reactive.event(input.accept_CL, ignore_none=False)
    def dopasowanie_krzywej_factor_interaktywne():
        ys = wsp_mult_paid()[1]
        xs = wsp_mult_paid()[0]
        list_curve = ['Exponential', "Weibull", "Power", "Inverse Power"]
        parameters_curve = yh.parameters_curve_rezerwy(xs, ys, list_curve, "Paid")

        return (parameters_curve)



    @reactive.Calc
    # @reactive.event(input.accept_CL, ignore_none=False)
    def predykcja_krzywej_factor_interaktywne():
        parameters_curve = dopasowanie_krzywej_factor_interaktywne()
        list_curve = ['Exponential', "Weibull", "Power", "Inverse Power"]
        xs_pred = np.array(np.arange(1, len(wspolczynniki_multiplikatywna_interaktywna().iloc[1, 1:]) + 1))
        f_curves_graph_real = yh.sim_data_curve_rezerwy(xs_pred, list_curve, parameters_curve)
        f_curves_graph_real.insert(0, "Krzywa", list_curve)
        return (f_curves_graph_real)

    def change_ind_to_col(df_data, name_col):
        if (name_col in df_data.columns.to_list()):
            df_data = df_data.copy()
        else:
            df_data.insert(0, name_col, df_data.index)
        return (df_data)

    @reactive.Calc
    # @reactive.event(input.accept_CL, ignore_none=False)
    def r2_df_freq_lc_interaktywny():
        ys = wsp_mult_paid()[1]
        xs = wsp_mult_paid()[0]
        list_curve = ['Exponential', "Weibull", "Power", "Inverse Power"]
        parameters_curve = dopasowanie_krzywej_factor_interaktywne()
        f_curves_graph_real_choose = yh.sim_data_curve_rezerwy(xs, list_curve, parameters_curve)
        r2_curves_df = yh.r2_curves(f_curves_graph_real_choose, ys)
        return (r2_curves_df)

    @output
    @render.data_frame
    def wspol_z_krzywej_CL_paid_interaktywna():
        II_dataframe = predykcja_krzywej_factor_interaktywne()
        return render.DataGrid(
            II_dataframe,
            width="100%",
            height="100%",
            summary=False
            #row_selection_mode='single'
        )

    @output
    @render.data_frame
    def r2_cl_paid():
        r2_freq_lc = change_ind_to_col(r2_df_freq_lc_interaktywny(), 'Wartość')
        return render.DataGrid(
            r2_freq_lc,
            width="100%",
            height="100%",
            summary=False,
        )

    @output
    @render.plot()
    def plot_wspolczynniki_dopasowane_interaktywny():
        factor_paid = wspolczynniki_multiplikatywna_interaktywna().iloc[1, 1:]
        xs_input = np.arange(1, len(factor_paid) + 1)
        f_curves_tail_graph = predykcja_krzywej_factor_interaktywne().iloc[:, 1:]
        fig = plt.figure()
        for index_loop, row in f_curves_tail_graph.iterrows():
            plt.plot(row, '-', label=str(index_loop))
        plt.plot(factor_paid, 'o-', linewidth=1, label='Initial Selection')
        plt.legend()
        fig.autofmt_xdate()
        return fig


    @output
    @render.data_frame
    def Factors_curve_and_initial():
        f_curves_tail_graph_cop = predykcja_krzywej_factor_interaktywne()
        f_curves_tail_graph_cop.loc[len(f_curves_tail_graph_cop)] = ['Initial'] + wspolczynniki_multiplikatywna_interaktywna().iloc[
                                                                                     1, 1:].tolist()
        return render.DataGrid(
            f_curves_tail_graph_cop,
            width="100%",
            height="100%",
            summary=False,
        )

    def predykcja_krzywej_factor_interaktywne_tail():
        parameters_curve = dopasowanie_krzywej_factor_interaktywne()
        list_curve = ['Exponential', "Weibull", "Power", "Inverse Power"]
        xs_pred = np.array(
            np.arange(1, len(wspolczynniki_multiplikatywna_interaktywna().iloc[1, 1:]) + 1 + int(input.num_tail())))
        f_curves_graph_real = yh.sim_data_curve_rezerwy(xs_pred, list_curve, parameters_curve)
        f_curves_graph_real.insert(0, "Krzywa", list_curve)
        return (f_curves_graph_real)

    @reactive.Calc
    @reactive.event(input.accept_final_factor, ignore_none=False)
    def calc_Final_Factor():
        df_all_trin_factor = predykcja_krzywej_factor_interaktywne_tail()
        fact_real = wspolczynniki_multiplikatywna_interaktywna().iloc[1, 1:].tolist()
        Final_factors = yh.chose_factor_indywidualny(df_all_trin_factor, fact_real, input.num_of_first_factor())
        return (Final_factors)

    @output
    @render.data_frame
    def Final_Factor():
        Final_factors = calc_Final_Factor()
        return render.DataGrid(
            Final_factors,
            width="100%",
            height="100%",
            summary=False,
        )

    @output
    @render.data_frame
    def Choose_Factor():
        Final_factors = calc_Final_Factor()
        Choose_factors = pd.DataFrame(
                                      columns=['Choose'] + ['dp: ' + str(x) for x in range(1, Final_factors.shape[1])],
                                      index=["Wybrana krzywa"])
        Choose_factors.iloc[0, :] = Final_factors.loc[input.wyb_krzywa_ogona()].to_list()
        return render.DataGrid(
            Choose_factors,
            width="100%",
            height="100%",
            summary=False,
        )

    @reactive.Calc
    def calc_chainladder_interaktywne():
        Final_factors = calc_Final_Factor()
        trian_list = every_triangle()[0]
        triangle = trian_list[index_lini_CL_Paid()].iloc[:, 1:]
        CL_fit = Final_factors.loc[input.wyb_krzywa_ogona()].to_list()
        Dev_j_base = wspolczynniki_multiplikatywna_interaktywna().iloc[0, 1:].to_list()
        Dev_j_z_wagami = wspolczynniki_multiplikatywna_interaktywna().iloc[1, 1:].to_list()
        data_output = pd.DataFrame(0, index=np.arange(0, triangle.shape[0] + 1),
                                   columns=['Rok/Suma', 'Ult_base', 'IBNR_base', 'Ult z wagami', 'IBNR z wagami',
                                            'Ult z krzywą', 'IBNR z krzywą'])
        data_output.iloc[:, 0] = np.arange(0, triangle.shape[0] + 1)
        k = 1

        for wspolczynniki in [Dev_j_base, Dev_j_z_wagami, CL_fit[1:]]:
            proj_triangle = yh.triangle_forward(triangle, wspolczynniki, 0)
            print(proj_triangle.to_string())
            diag = yh.reverse_list(yh.trian_diag(triangle))
            Ultimate_Param_ReservingRisk = proj_triangle.iloc[:, int(proj_triangle.columns[-1]) - 1].to_list()
            data_output.iloc[:, k] = Ultimate_Param_ReservingRisk + [np.sum(Ultimate_Param_ReservingRisk)]
            k = k + 1
            BE_Param_ReservingRisk = [x - y for x, y in zip(Ultimate_Param_ReservingRisk, diag)]
            data_output.iloc[:, k] = BE_Param_ReservingRisk + [np.sum(BE_Param_ReservingRisk)]
            k = k + 1
        return (data_output)

    @output
    @render.data_frame
    def Ult_BE_data_interaktywne():
        df = calc_chainladder_interaktywne()
        trian_list = every_triangle()[0]
        triangle = trian_list[index_lini_CL_Paid()].iloc[:, 0].tolist()
        df.iloc[:, 0] = triangle + ["Suma"]
        df.iloc[:,1:] = df.iloc[:,1:].map(lambda x: f"{x:,.2f}".replace(",", " ") if isinstance(x, (int, float)) else x)
        return render.DataGrid(
            df,
            width="100%",
            height="150%",
        )

